package service;

import com.google.gson.*;
import com.google.gson.annotations.Expose;
import com.sun.net.httpserver.HttpExchange;
import com.sun.net.httpserver.HttpHandler;

import java.io.*;
import java.util.HashMap;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * Processes a request from a client for JSON validation.
 * <p>
 * The class reads a payload in the request (means HTTP POST request) and tries to parse the JSON using
 * Google Gson library. If parsing was successful then the same JSON is sent, though it is pretty print first,
 * i.e. formatted for better human readability. It sends JSON with error details in case of violation of the format
 * rules.
 * <p>
 * JVS uses <a href="https://github.com/google/gson"><strong>Google Gson</strong></a> library which is able to
 * deserialize a JSON described in <a href="http://www.ietf.org/rfc/rfc7159.txt">RFC 7159</a>.
 * Thus error-handling is based on the messages from the {@code com.google.gson.stream.JsonReader.java}.
 * Yet these messages are well-described to be used by JVS.
 * <p>
 * If a JSON is malformed, the error message is sent such as the following:
 * <pre>
 *     "errorCode"  : 12345,
 *     "errorMessage" : "verbose, plain language description of the problem with hints about how to fix it",
 *     "errorPlace" : "the point where error has occurred",
 *     "resource"   : "filename",
 *     "request-id" : "the request id generated by the API for easier tracking of errors"
 * </pre>
 * <ul>
 *     <li>{@code errorCode}  is a value listed in {@code BadJSONResponse.ERRORS} or zero if some unhandled error
 *     is occurred</li>
 *     <li>{@code errorMessage} and {@code errorPlace}  are taken from the caught exception that is thrown
 *     by Gson's JsonReader.</li>
 *     <li>{@code resource}  a name that is retrieved from a HTTP request URI (path)</li>
 *     <li>{@code request-id}  an id of a request that is unique for the session</li>
 * </ul>
 * <p>
 * So when JVS determines that a JSON is not valid, it builds {@code BadJSONResponse} object with fields
 * as described above and serializes it to JSON format. Then JVS sends this JSON as a response for a client.
 * HTTP status code for any response is 200.
 */
public class JSONHandler implements HttpHandler {
    private static final Logger LOG = Logger.getLogger(JSONHandler.class.getName());

    private static int mRequestId = 0;

    private static class BadJSONResponse {

        @Expose
        private static final HashMap<String, Integer> ERRORS = new HashMap<String, Integer>() {
            {
                put("Unterminated array", 1);
                put("Unterminated object", 2);
                put("Expected name", 3);
                put("Expected \':\'", 4);
                put("Unexpected value", 5);
                put("Expected value", 6);
                put("Unterminated string", 7);
                put("Unterminated comment", 8);
                put("Use JsonReader.setLenient(true) to accept malformed JSON", 9);
                put("Unterminated escape sequence", 10);
                put("Invalid escape sequence", 11);
                put("JSON forbids NaN and infinities", 12);
            }
        };

        int errorCode;
        String errorMessage;
        String errorPlace;
        String resource;
        int requestId;

        BadJSONResponse(String cause, String path) {
            Pattern pattern = Pattern.compile("(.+) (at.*)");
            Matcher matcher = pattern.matcher(cause);
            if(matcher.find()) {
                errorMessage = matcher.group(1);
                errorPlace = matcher.group(2);
            }

            Integer err = ERRORS.get(errorMessage);
            errorCode = (null != err) ?  err : 0;
            if(0 == errorCode) {
                LOG.log(Level.WARNING, "Unexpected error message: {0}", errorMessage);
            } else if(9 == errorCode) {
                errorMessage = "Malformed JSON";
            }

            resource = path;
            requestId = mRequestId;
        }
    }

    /**
     * Performs validation of a client request.
     * <p>
     * The callback invokes by {@code HttpServer} on incoming request from a client.
     * It reads a payload from a request and performs validation. If validation is complete,
     * it sends {@code HTTP OK} response with {@code Content-Type: application/vnd.api+json}.
     *
     * @param t  {@code HttpExchange} instance passing by HttpServer.
     * @throws IOException  if sending a response is not possible.
     */
    @Override
    public void handle(HttpExchange t) throws IOException {
        String request = readRequest(t.getRequestBody());
        String path = t.getRequestURI().getPath();
        path = path.replaceFirst("^/", "");
        path = ("".equals(path)) ? "json" : path;

        String response = validateRequest(request, path);

        t.getResponseHeaders().set("Content-type", "application/vnd.api+json");

        t.sendResponseHeaders(java.net.HttpURLConnection.HTTP_OK, response.length());
        OutputStream os = t.getResponseBody();
        os.write(response.getBytes());
        os.close();
    }

    private String readRequest(InputStream stream) {
        StringBuilder builder = new StringBuilder();
        InputStream inputStream = new BufferedInputStream(stream);
        BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream));

        String line;
        try {
            while ((line = reader.readLine()) != null) {
                builder.append(line).append('\n');
            }
            stream.close();
        } catch (IOException e) {
            LOG.log(Level.SEVERE, "Exception has occurred during reading a request body", e);
        }
        return builder.toString();
    }

    private String validateRequest(String request, String path) {
        StringBuilder response = new StringBuilder();

        Gson gson = new GsonBuilder().setPrettyPrinting().create();
        JsonParser parser = new JsonParser();
        JsonElement json;

        ++mRequestId;
        try {
            json = parser.parse(request);

            response.append(gson.toJson(json));
        } catch (JsonSyntaxException e) {
            BadJSONResponse resp = new BadJSONResponse(e.getCause().getMessage(), path);

            response.append(gson.toJson(resp));
        }
        return response.append('\n').toString();
    }
}